<h1>HTML</h1>

- [DOCTYPE 的作用](#doctype-的作用)
- [如何理解HTML语义化](#如何理解html语义化)
- [行内元素与块级元素的区别](#行内元素与块级元素的区别)
- [空元素](#空元素)
- [渐进增强和优雅降级](#渐进增强和优雅降级)
- [meta 标签](#meta-标签)
- [head 标签中必不少的是什么](#head-标签中必不少的是什么)
- [使用过哪些H5新标签？在什么场景下应用的](#使用过哪些h5新标签在什么场景下应用的)
- [HTML5 新增的表单元素有哪些](#html5-新增的表单元素有哪些)
- [disabled 和 readonly 的区别](#disabled-和-readonly-的区别)
- [Label 的作用是什么？是怎么用的](#label-的作用是什么是怎么用的)
- [async 和 defer 的作用是什么？有什么区别？](#async-和-defer-的作用是什么有什么区别)
- [CSS如何阻塞文档解析](#css如何阻塞文档解析)
- [重绘和回流](#重绘和回流)
- [常见的浏览器端的存储技术有哪些？有什么区别？](#常见的浏览器端的存储技术有哪些有什么区别)
- [前端需要注意哪些SEO](#前端需要注意哪些seo)

---


### DOCTYPE 的作用

`<!DOCTYPE>` 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来
进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏
览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。

### 如何理解HTML语义化

- html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析
- 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的
- 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO
- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解

### 行内元素与块级元素的区别
- 行内元素：HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空
间。常见的行内元素有 `a b span img strong sub sup button input label select textarea`
- 块级元素: 占据其父元素（容器）的整个宽度，因此创建了一个“块”。常见的块级元素有  `div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p `
- 区别：
  - 默认情况下，行内元素不会以新行开始，而块级元素会新起一行
  - 行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素
  - 行内元素设置 width 无效，height 无效（可以设置 line-hei
     ght），设置 margin 和 padding 的上下不会对其他元素产生影响

### 空元素

标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。`常见的空元素有：br hr img input link meta`

### 渐进增强和优雅降级

- 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
- 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容

### meta 标签

> `<meta>` 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。`<meta>` 标签位于文档的头部，不包含任何内容。


- `<meta charset=’utf-8′>`    声明文档使用的字符编码
- `<meta name=”description” content=”不超过150个字符”/>`       页面描述
- `<meta name=”keywords” content=””/> ` 页面关键词
- `<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”>` 为移动设备添加 viewport
  - Viewport是视觉窗口是移动端特有的，这是一个虚拟的区域，用来承载网页。PC端的页面直接就承载在浏览器窗口里面，而移动端多出了这样一个虚拟区域，用它来承载网页。在移动端，它们之间的关系是：浏览器承载viewport，viewport承载网页。将写好的页面放在移动端显示，会出现缩放的现象，之前的字体变小了，如何解决这个问题？
  - 需要一个适配方案，这个适配方案有一定的要求：
首先，网页宽度必须和浏览器保持一致，默认显示的缩放比例要和PC端保持一致（缩放比例是1.0），不允许用户自行缩放网页。满足上述的要求，就达到了适配，是国际上通用的适配方案，标准的移动端适配方案。
书写位置：在head里面并且应该紧跟着编码设置，是为了保证能够优先加载。`<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">`或者`<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">`页面的真实尺寸会比在设备上的尺寸要大几倍，比如说initial-scale=0.5就说明页面的真实尺寸比设备上的尺寸要大2倍。这个时候使用的时要注意缩放。


### head 标签中必不少的是什么

`<head>` 标签用于定义文档的头部，它是所有头部元素的容器。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数
 据都不会真正作为内容显示给读者。`<head>` 部分可以包含：`<base>`, `<link>`, `<meta>`, `<script>`, `<style>`, 以及 `<title>`，其中，`<title>` 定义文档的标题，它是 head 部分中唯一必需的元素。

### 使用过哪些H5新标签？在什么场景下应用的

### HTML5 新增的表单元素有哪些

### disabled 和 readonly 的区别

### Label 的作用是什么？是怎么用的

### async 和 defer 的作用是什么？有什么区别？

- 脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
- defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。
- async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。

### CSS如何阻塞文档解析

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。

### 重绘和回流

### 常见的浏览器端的存储技术有哪些？有什么区别？

cookie、localStorage 和 sessionStorage

SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别
 在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户
 本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会
 在浏览器和服务器间来回传递。
 
 
 存储大小：
   	cookie 数据大小不能超过4 k 。
   	sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。

 有期时间：
   	localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
   	sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会
                     保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
   	cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
  
 作用域：
     sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
     localStorage    在所有同源窗口中都是共享的。
     cookie          在所有同源窗口中都是共享的。


cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。

sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源
页面所访问共享。

localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。

### 前端需要注意哪些SEO