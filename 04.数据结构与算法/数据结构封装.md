- [数据结构](#数据结构)
  - [链表封装](#链表封装)
  - [双向链表](#双向链表)

## 数据结构

### 链表封装
```javascript
//  链表结构非常重要！！！  栈，队列 都能通过链表来实现
// append(element)： 向列表尾部添加一个新的项
// insert(position, element)： 向列表的特定位置插入一个新的项。
// remove(element)： 从列表中移除一项。
// indexOf(element)： 返回元素在列表中的索引。 如果列表中没有该元素则返回 - 1。
// removeAt(position)： 从列表的特定位置移除一项。
// isEmpty()： 如果链表中不包含任何元素， 返回true， 如果链表长度大于0则返回false。
// size()： 返回链表包含的元素个数。 与数组的length属性类似。
// toString()： 由于列表项使用了Node类， 就需要重写继承自JavaScript对象默认的toString方法， 让其只输出元素的值。

// 单向链表的封装
function LinkedList() { 
    // 因为每个元素里面有两部分， 所以先提前封装一个   内部类（Java中的说法）
    function Node(data) {  
        this.data = data;
        this.next = null;
    }

    // 属性
    this.head = null;  // 指向第一个节点
    this.length = 0;  // 记录链表的长度 

    // 1. append方法：  
    // 两种情况：
        // 链表本身为空, 新添加的数据是唯一的节点，即完成 创建节点+将head的指针指向这个节点
        // 链表不为空, 需要向其他节点后面追加节点.
    LinkedList.prototype.append = function (data) {
        
        // 根据新元素创建节点
        var newNode = new Node(data);

        // 判断当前添加的是否是第一个节点
        if (this.length == 0) { // 是第一个节点
            // head指针指向这个新节点
            this.head = newNode;
        }else { // 当前插入的节点不是第一个节点
            
            // 去查找最后一个节点
            // 拿一个中间桥梁来寻找哪个元素的next指向的是null， next指向null的这个元素就是最后一个元素
            var current = this.head;
            while (current.next) { // 如果当前的这个不是null
                current = current.next;
            }

            // current 是循环之后找到的那个最后节点, 让这个元素的next指向新创建的这个节点
            current.next = newNode;
        }

        // 在这里， 一个新节点已经添加进去了， 此时链表的长度需要+1
        this.length += 1;
    };

    // 2. toString()方法:  实现思路： 
    // 从head开头, 因为获取链表的任何元素都必须从第一个节点开头.循环遍历每一个节点, 并且取出其中的data, 拼接成字符串.
    // 将最终字符串返回.
    LinkedList.prototype.toString = function () {  
        // 定义变量
        var current = this.head;
        var listString = '';

        // 循环获取每一个节点
        while (current) { // 如果当前不是null，就进行字符串的拼接
            listString += current.data + ' ';
            current = current.next;
        }

        return listString;
    };

    // 3. insert方法： 在链表的任意位置插入数据
    LinkedList.prototype.insert = function (position, data) {  
        // 1. 对position进行越界判断
        if (position < 0 || position > this.length) return false;

        // 2. 根据data创建newNode
        var newNode = new Node(data);

        // 3. 判断插入的位置是不是第一个    
        if (position == 0) {
            newNode.next = this.head; // 先让先创建的这个节点的next指针指向原来的第一个节点
            this.head = newNode;  // head指向新创建的这个节点
        }else {
            // 从头开始找，首先找到那个需要插入节点的位置
            var index = 0;
            var current = this.head;
            var previous = null;   // 默认是null， 因为current指向第一个的时候，它的前一个就是null
            while(index++ < position) {
                previous = current;
                current = current.next;  // current变量中存放的是需要找的那个节点
            }

            // 循环结束之后就找到了原链表中需要插入节点的那个位置的节点，这时让newNode的next指向这个节点（相当于把newNode插入到这个节点前面）
            newNode.next = current;  // 下一步就是需要将这个位置的前一个位置的节点的next指向newNode，  所以需要找到插入位置的前一个节点， previous
            previous.next = newNode;

            // 将新的节点插入到链表的最后  这种情况也包含在这个分支里面了
        }

        // 4. 插入了一个元素，  这个链表的长度+1
        this.length += 1;
    };

    // 4. get方法：  根据传入的位置信息， 来获取这个位置的data数据
    LinkedList.prototype.get = function (position) {  
        // 传入的是地址，先进行越界判断
        if (position < 0 || position >= this.length) return null;

        var current = this.head;
        var index = 0;
        while (index++ < position) {
            current = current.next;
        }

        return current.data;
    };

    // 5. indexOf方法： 查看一个data在链表中的位置, 找到的话返回坐标位置， 没有找到的话返回-1
    LinkedList.prototype.indexOf = function (data) {  
        // 1. 定义变量
        var current = this.head;
        var index = 0;

        // 开始查找
        while(current) {
            if (current.data == data) { // 如果相等的话，就说明是需要查找的那个元素，就可以直接返回对应的index
                return index;
            }

            // 如果不相等， 也就是说没有执行if语句，就会继续往后查找
            current = current.next;
            index++;
        }

        // 如果整个while里面都没有。 就说明这个链表中没有这个元素
        return -1;
    };

    // 6. update方法，  输入参数， 位置，数据 --- 与get方法一致， 只不过是找到那个位置的节点，将这个节点中的data换成传入的这个data
    LinkedList.prototype.update = function (position, data) {  
        // 1. 进行越界判断
        if (position < 0 || position >= this.length ) return false;

        // 2. 循环查找position那个位置的节点
        var current = this.head;
        var index = 0;
        while(index++ < position) {
            current = current.next;
        }

        // 循环结束就找到了对应的这个位置， 将这个位置上的数据进行替换
        current.data = data;
        return true; // 返回true表示修改成功
    };

    // 7. removeAt方法:  删除指定位置的一个节点，返回值为删除的这个节点的data数据
    LinkedList.prototype.removeAt = function (position) {  
        // 只要是跟位置有关的都要进行越界判断
        if (position < 0 || position >= this.length ) return null;

        // 判断position == 0？
        var current = this.head;
        if (position == 0) {
            // 如果是删除第一个节点，直接让head的指针指向下一个节点即可
            this.head = this.head.next;
        }else { // 进入这个分支表示需要删除的是在链表中的某个节点:思路是将需要删除的节点的next指向删除节点的next
            var index = 0;
            var previous = null; 
            while(index++ < position) {
                previous = current;
                current = current.next;
            }

            // 循环结束，就表示找到了， 改变指针方向
            previous.next = current.next;
        }

        this.length -= 1;
        // 返回找到的这个节点的data数据
        return current.data;
    };

    // 8. remove方法， 根据传入的data数据删除节点， --- 前面已经封装了indexOf和removeAt方法， 我们可以直接调用这两个方法来实现
    LinkedList.prototype.remove = function (data) {  
        // 获取data在链表中的位置
        var position = this.indexOf(data);

        // 根据位置信息，删除节点
        return this.removeAt(position);
    };

    // 9. isEmpty方法
    LinkedList.prototype.isEmpty = function () {  
        return this.length == 0;
    };

    // 10. size方法
    LinkedList.prototype.size = function () {  
        return this.length;
    };

}

// 测试代码
 var list = new LinkedList();

 // append方法
 list.append('asd');
 list.append('ad');
 list.append('abc');

 // toString方法
//  console.log(list);
 console.log(list.toString());

// insert方法
list.insert(1, 'milly');
console.log(list.toString());

// get方法
 console.log(list.get(1));
 console.log(list.indexOf('milly'));

 // update方法
console.log(list.update(0, 'aaaaaa'));
console.log(list.toString());

// removeAt方法  删除position ==0的节点
console.log(list.removeAt(0));
console.log(list.toString());

// remove方法
console.log(list.remove('abc'));
console.log(list.toString());

// isEmpty方法 和size方法
console.log(list.isEmpty());
console.log(list.size());

```

### 双向链表
