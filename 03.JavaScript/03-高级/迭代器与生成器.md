- [迭代器](#迭代器)
- [生成器](#生成器)
- [执行器](#执行器)
- [promise](#promise)
- [async  await](#async--await)

## 迭代器

问题：遍历与迭代的关系是什么？

为了解释遍历与迭代之间的关系，首先看几个最简单的例子：
```javascript
var arr = [1, 2, 3, 4];
var str = '123';
var obj = { a: 1, b: 2 };

// 遍历数组
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i])
}

arr.forEach(function (item) {
  console.log(item);
});

// 遍历字符串
for (var i = 0; i < str.length; i++) {
  console.log(str[i])
}

// 遍历对象
for (var i in obj) {
  console.log(i, obj[i]);
}

function test() {
  console.log([...arguments]);

}

test(1, 2, 3, 4)
```
以上代码中列出的是JS中很常见的三种数据类型：Array, string, object, 并且列出了遍历这三种数据类型的方法。不同的数据类型会有不同的遍历方法，有没有一种方式能够实现一种统一的数据类型的遍历呢？迭代器的出现就是为了实现所有数据类型的统一遍历。

`Array, Map, Set, TypeArray, arguments, NodeList`这几种类型都是能够实现一步遍历的， 即可以使用`for...of`实现遍历。
```javascript
var arr = [1, 2, 3, 4];
var str = '123';
var obj = { a: 1, b: 2 };

for (let i of arr) {
  console.log(i)  // 正常遍历
}

for (let i of str) {
  console.log(i)  // 正常遍历
}

for (let i of obj) {
  console.log(i)  // Uncaught TypeError: obj is not iterable
}
```
上述代码可以发现，`for...of`能够实现对数组和字符串的遍历，但是对象不能使用`for...of`进行遍历，为什么？

可以打印看一下：
```javascript
var arr = [1, 2, 3, 4];
var str = '123';
var obj = { a: 1, b: 2 };
console.log(arr);
console.log(Object.getPrototypeOf(str));
console.log(obj);
```
可以看到在arr的原型上有一个方法叫：`Symbol(Symbol.iterator)`,str原型上也有这个方法，但是obj上没有。也就是说，原型上部署了这样一个方法的话，就可以使用`for...of`进行遍历。

看一下arr原型上的这个`Symbol(Symbol.iterator)`方法，

```javascript
console.log(arr[Symbol.iterator]())

// Array Iterator {}
//      __proto__: Array Iterator
//          next: ƒ next()
//          Symbol(Symbol.toStringTag): "Array Iterator"
//          __proto__: Object
```
可以看到里面有一个next方法,调用一下试试看：
```javascript
var iter = arr[Symbol.iterator]();
console.log(iter.next());   // {value: 1, done: false}
```
会发现，输出的是一个对象，其中，value表示数组中第0个元素的值，done表示是否完成迭代，上面输出的是false，说明没有完成迭代，还可以继续调用：
```javascript
var iter = arr[Symbol.iterator]();
console.log(iter.next());   // {value: 1, done: false}
console.log(iter.next());   // {value: 2, done: false}
console.log(iter.next());   // {value: 3, done: false}
console.log(iter.next());   // {value: 4, done: false}
console.log(iter.next());   // {value: undefined, done: true}
```
现在可以解释什么是迭代器对象了：`arr[Symbol.iterator]()`就是迭代器对象。可以发现，迭代器对象是有一个next方法的，可以使用next方法实现逐步调用，在逐步调用的过程中返回一个对象，这个对象中包含`value、done`两个属性。

能不能使得对象也能使用`for...of`进行遍历呢？可以。

先来看如何实现一个自定义的迭代器：
```javascript
function makeIterator(arr) {
    var index = 0;
    return {
        next() {
            if (index < arr.length) {
            return { value: arr[index++], done: false }
            }
            return { value: undefined, done: true };
        }
    }
}

var arr = [1, 2, 3, 4];
var iter = makeIterator(arr);
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
```

实现：使用`for...of`遍历对象。
```javascript
var obj = {
  a: 1,
  b: 2,
  c: 3,
  [Symbol.iterator]() {
    var index = 0;
    let map = new Map();  // 
    map.set('a', 1)
    map.set('b', 2)
    map.set('c', 3)
    // console.log(map);
    return {
      next() {
        // 获取obj的键值对组成的数组
        var mapEntries = [...map.entries()];  // ... 调用的就是for...of方法
        if (index < map.size) {
          return { value: mapEntries[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    }
  }
};

var iter = obj[Symbol.iterator]();
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
```

`for..of`的本质：调用`[Symbol.iterator]`迭代器接口，我们已经给obj部署了这个接口，现在就可以使用`for..of`遍历obj了：

```javascript
for (var i of obj) {
  console.log(i);
}
```

小结：遍历与迭代的区别？

遍历：不强调依次，逐个，只要能循环所有的数据，可以一次性将数据抽取出来；

迭代：从目标源依次、逐个抽取的方式来提取数据;  数据结构要保证是_**`有序的, 连续的`**_。比如，Array, Set, Map, arguments,NodeList上是有index的保证有序与连续。

这里就看下NodeList：

hmtl部分：
```html
<div></div>
<div></div>
<div></div>
<div></div>
```
js部分
```javascript
var nodeList = document.getElementsByTagName('div');
console.log(nodeList);
// 0: div
// 1: div
// 2: div
// 3: div
// length:4
// __proto__

for (var i of nodeList) {
  console.log(i);
}
```

通过上述的分析会发现，`Array, Map, Set, TypeArray, arguments, NodeList`这几种类型都能够使用`for...of`实现一步遍历，但是对于object来说并不方便，如果要实现这样的迭代就要像上面一样部署迭代器接口，比较麻烦，那有没有更简单的方法可以生成迭代器对象，让这个迭代器对象能够直接实现遍历？  --- 生成器。所以生成器是为了生成迭代器的。


## 生成器

最简单的生成器形式：
```javascript
function* test() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

var iter = test();
console.log(iter.next());  // {value: 1, done: false}
console.log(iter.next());  // {value: 2, done: false}
console.log(iter.next());  // {value: 3, done: false}
console.log(iter.next());  // {value: 4, done: false}
console.log(iter.next());  // {value: undefined, done: true}

for (var i of iter) {
  console.log(i);
}
```

具体来看下是如何调用的：
```javascript
function* test() {
    console.log(1);
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

var iter = test();
// console.log(iter);
```

```javascript
function* test() {
    console.log(1);
    yield 1;
    console.log(2);
    yield 2;
    yield 3;
    yield 4;
}

var iter = test();
console.log(iter.next());
// 1
// {value: 1, done: false}
console.log(iter.next());
// 2
// {value: 2, done: false}
```
第一段代码，没有任何内容输出，第二段代码调用了next方法之后输出了1，并且输出了`{value: 1, done: false}`对象，也就是说，在调用next之前，生成器函数并不会执行，每调用一次next方法，就会执行到yield之后。实际上，yield能够中断函数，有点像return，但是又不一样。

```javascript
function* test() {
    console.log(1);
    return 1;
}

var iter = test();
console.log(iter);
```
将生成器函数中的yield换成return，发现，生成器函数也没有执行，返回的是一个迭代器对象(里面有next方法)，也就是说，生成器函数中的返回值并不由return来决定，而是由yield来决定，在执行next方法之后才会继续往下走，走到return，

## 执行器

## promise

## async  await