- [数据类型检测的方法](#数据类型检测的方法)
- [使用var声明变量与不使用var变量直接赋值的区别](#使用var声明变量与不使用var变量直接赋值的区别)
- [说一下JS中的delete](#说一下js中的delete)

## 数据类型检测的方法

> typeof 检测数据类型的逻辑运算符
> 
> instanceof 检测是否为某个类的实例
> 
> constructor 检测构造函数
> 
> Object.prototype.toString.call() 检测数据类型

> 这一部分主要分析`typeof`如何检测数据类型

1. `typeof [value]` 返回结果是对应数据类型的字符串
   
   ```javscript
    console.log(typeof 12)  // "number"
    console.log(typeof NaN)  // "number"
    console.log(typeof Infinity)  // "number"
    console.log(typeof true)  // "boolean"
    console.log(typeof "xiaoming")  // "string" 
    console.log(typeof null)  // "object"
    console.log(typeof undefined)  // "undefined"
    console.log(typeof Symbol('1'))  // "symbol"
    console.log(typeof BigInt('1'))  // "bigint"
    console.log(typeof [])  // "object"
    console.log(typeof {})  // "object"
    console.log(typeof function () {})  // "function"
   ```
注意：null本身是基本数据类型的，但是typeof检测得到的结果是`"object"`，这是因为所有值在内存中都是按照二进制位存储的，typeof在检测的时候认为前几位都是0的就是`"object"`，null存储的结果正好前几位都是0。

 - 特点总结：
   - 返回的结果都是字符串
   - 局限性
     - `console.log(typeof null)  // "object"`
     - typeof不能细分对象类型(检测普通对象和数组对象都是object)

2. JS中的数字类型：
- 数字类型分类：
  - 0、1、 2、 -1、 1.3、 1.02，正整数、负整数、零、小数都是数字类型
  - NaN：它表示不是一个有效数字，但是它属于number类型
  - Infinity：无穷大的值
  - -Infinity：负无穷大的值
- NaN：不等于任何值，包括它自己
  - `NaN == NaN` 结果为false
  - 判断一个值是不是有效数字：使用全局方法`isNaN(值)` --- 检测这个值是否不是有效数字，如果不是有效数字，返回true，如果是有效数字，返回false

3. 把其它数据类型转换为数字
   1. 强转换（基于底层机制转换的） `Number([value])`
      1. 一般很少自己写Number去进行类型转换，存在一些隐式类型转换都是基于Number完成的
         1. `isNaN('12px')`： 先把其它类型值转换为数字再检测
         2. 数学运算: '12px'-13
         3. `字符串 == 数字`：两个等于号比较，很多时候也是要把其它值转换为数字再进行转换
   2.  弱转换（基于一些额外的方法转换） `parseInt([value])/parseFloat([value])`

4. 例题分析

```javascript
let a = typeof typeof typeof [1,2,3]
console.log(a)  // "string"
```
- 分析：`typeof [1, 2, 3] =>"object"` -> `typeof "object" =>"string"` -> `typeof "string" =>"string"`

---
```javascript
let res = parseFloat('left:200px');
if(res===200){
   alert(200);
}else if(res===NaN){
   alert(NaN);
}else if(typeof res==='number'){
   alert('number');
}else{
   alert('Invalid Number');
}

// 结果："number"
```
- 分析：
  - `parseFloat()`:实现数字类型转换，将字符串转换成数字类型，从左往右开始查找，找到数字依次转换为数字，如果检测到不是数字就转换为NaN,只要检测到一个不是数字就停止查找了,如果处理的值不是字符串，需要先转换为字符串然后再开始查找接口。 所以`res=NaN`
  - 第一个分支肯定不成立，第二个分支也不成立，因为`NaN !== NaN`
  - 到第三个分支: `typeof res`结果为字符串"number"，所以该分支成立，弹出"number"

---
```javascript
parseInt("")  // NaN
Number("")  // 0
isNaN("")  // isNaN(0) -> false

parseInt(null)  // NaN
Number(null)  // 0
isNaN(null)  // isNaN(0) -> false

parseInt("12px")  // 12
Number("12px")  // NaN
isNaN("12px")  // isNaN(NaN) -> true

parseFloat("1.6px")+parseInt("1.2px")+typeof parseInt(null)  // 1.6 + 1 + "number"  -> 2.6 + "number" -> "2.6number" 

isNaN(Number(!!Number(parseInt("0.8"))))  // isNaN(0) -> false

typeof !parseInt(null) + !isNaN(null)  // "booleantrue"

[] == true  // false  
```
- 分析：
    - parseInt 处理的值是字符串，从字符串的左侧开始查找有效数字字符（遇到非有效数字字符则停止查找），如果处理的值不是字符串，需要先转换为字符串然后再开始查找接口。
    - Number 直接调用浏览器最底层的数据类型检测机制来完成，有以下几个规定：
      - `Number(true) -> 1`, `Number(false) -> 0`
      - `Number(null) -> 0`, `Number(undefined) -> NaN`
      - `Number("") -> 0`
      - `Number([]) -> Number("") -> 0`
      - 字符串中必须保证都是有效数字才会转换为数字，否则都是NaN, 比如`Number("12px")  // NaN`
    - `isNaN()`使用的是隐式转换：比如`isNaN("")`, 先把""转换为数字（隐式 Number），相当于先执行`Number("")` 再执行 `isNaN(0)`，所以结果为false
    - `+`在JS中除了数学运算还有字符串拼接的作用, `+`遇到字符串(或者对象，因为对象是先转换为字符串然后再处理)
    - 其他类型转换为布尔为false：
      - `0 -> false`
      - `NaN -> false`
      - `null -> false`
      - `undefined -> false`
      - `"" -> false`
    - 两个等号比较的时候，等号两边一个是对象一个是布尔，在比较的时候先进行隐式转换(Number)，都转换成数字类型，`Number([]) -> Number("") -> 0`，`Number(true) -> 1`，所以`[] == true  // false`。两个等号比较的时候有几个规律：
      - `对象 == 字符串`： 对象转换为字符串
      - `null == undefined`: null和undefined相等，但是和其他值都不相等
      - 剩下的情况，如果两边是不同的类型，都是先转换成数字类型再进行比较

---
```javascript
let result = 10+false+undefined+[]+'Tencent'+null+true+{};
console.log(result);  // NaNTencentnulltrue[object Object]
```
- 分析：
    - `10+0 -> 10`
    - `10+NaN -> NaN`
    - `NaN+[] -> "NaN"`: 这里的运算遇到对象[]，对象先转换为字符串，`[] -> ""`，所以，得到的结果是字符串"NaN"。这个运算为什么转为字符串呢？原因是：现在要进行数学运算，要先转换成数字，要把对象转换成数字的过程是`对象 -> 字符串 -> 数字`，在对象转换成字符串的时候遇到加号就变成字符串拼接了。
    - `"NaN"+'Tencent' -> 'NaNTencent'`：现在是字符串了，后面就变成是字符串拼接了
    - -> `'NaNTencentnulltrue'`
    - 最后是一个对象，现将空对象转换成字符串,检测数据类型中有一个toString()，`({}).toString() -> "[object Object]"`
    - 一般，对象转为字符串的时候是先调用valueOf获得原始值再去调用toString，学习完面向对象之后再来理解这里！

5. 练习

```javascript
let str = 100 + true + 21.2 + null + undefined + 'Tencent' + [] + null + 9 + false

[] == false
![] == false
```

- 规律：在两边出现字符串或者对象的情况下，加号一定是字符串拼接。对象本身是要转换为数字进行运算的，只不过转换数字的过程中，需要先转换为字符串，而一旦转换成字符串，加号就变成字符串拼接了
- 对象转换成字符串：先调用valueOf获取其原始值(一般是基本类型值)，如果不是基本类型值，就继续调用toString()
- `==`在进行比较的时候，如果左右两边数据类型不一致，则需要先默认转换成一直的数据类型，然后再进行比较。`===`绝对相等，两边类型一致，值也一致才相等，类型不一样直接不对等，不会进行数据类型转换
- `==`比较规则：
  - `对象 == 字符串`,对象转换为字符串, `[10] == '10'  => true`
  - `null == undefined`, 但是和其他任何值都不相等，`0 == null => false`，虽然null在转换成数字类型的时候是0，但是这里是不相等的，可以这样理解，`0`一定会在内存中开辟一个值来存储的，，但是null直接不会分配内存。
  - NaN和谁都不相等，包括它自己
  - 剩下的情况都是转换成数字再比较
- `![] == false`考察点：
  - 优先级问题：先计算`![]`再计算`==`
  - `![]`:转换为布尔值取反。
    - 把其他类型转换为布尔类型：只有`0/NaN/null/undefined/''`这5种情况转换为布尔值是false，其他情况都是true
  - `false == fasle => true`
- 注意：浏览器底层运行的时候有一套自己的转换规则，`把其他值转换为数字`、`把其他值转换为布尔`、`==的比较`，这几个规则是互不干涉的。

---
```javascript
[] + 0 ? alert('ok') : alert('no')  // ok
0 + [] ? alert('ok') : alert('no')  // ok

{} + 0 ? alert('ok') : alert('no')  // no
0 + {} ? alert('ok') : alert('no')  // ok
```
- `[] + 0`:首先`[]`转换成数字，在转换成数字之前转换成字符串，转换成字符串之后就变成字符串拼接了，所以得到的结果是字符串`"0"`，`"0"`不是转换为布尔值的五种情况之一，所以转换为布尔值为true。第二行代码情况是一样的。
- `{} + 0`:
  - `{}`在JS中可以是对象，可以是代码块(块作用域)。在该题目的运算中，将`{}`当作一个代码块，后面是`+0`,所以浏览器运行的时候认为它是两个代码：代码块和`+0`运算。代码块不参与运算，只计算了`+0`，得到的结果是0。
  - `+值`这个操作是数学运算，不论这个值是什么类型的。`+[] => 0`、`+'10' => 10`、`++值`、`值++`也是数学运算
  - `{}`出现在运算符的前面，浏览器就认为它是一个单独的块，`{name: 'xiaoxiao'}+0 => 0`
  - 在浏览器`console.log({}+0) => "[object Object]0"`、`({}+0) => "[object Object]0"`，像这样的运算，浏览器就把这两部分看作是一个整体了。`({})+0 => "[object Object]0"`这样的话，浏览器认为`({})`不是代码块而是一个值。
- `0+{}`: `{}`出现在运算符后面，直接当作数学运算。
- `{} + 0 + {} => "[object Object]0[object Object]"`，特殊情况单独记。像是`{} + 0 + '10' => "010"`就是只计算后面的。


## 使用var声明变量与不使用var变量直接赋值的区别

1. 全局作用域内声明变量有var和没var的区别

```javascript
var aaa = 1
window.bbb = 2
ccc = 3
this.ddd = 4

// 使用getOwnPropertyDescriptor来查看window上这几个属性的特性描述
// getOwnPropertyDescriptor：获取指定对象的自身属性描述符。自身属性描述符是指直接在对象上定义（而非从对象的原型继承）的描述符。

Object.getOwnPropertyDescriptor(window, 'aaa')
// {value: 1, writable: true, enumerable: true, configurable: false}

Object.getOwnPropertyDescriptor(window, 'bbb')
// {value: 2, writable: true, enumerable: true, configurable: true}

Object.getOwnPropertyDescriptor(window, 'ccc')
// {value: 3, writable: true, enumerable: true, configurable: true}

Object.getOwnPropertyDescriptor(window, 'ddd')
// {value: 4, writable: true, enumerable: true, configurable: true}
```
通过上面的属性描述结果可以发现，在全局作用域下var的变量是window对象的一个属性，但是这个属性是**不可配置**的，关于是否可配置是与`Object.defineProperty`对象的数据属性相关的概念，比如：
```javascript
var person = {}
Object.defineProperty(person,'name',{
    configurable: false,//能否使用delete、能否修改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true
    enumerable: false,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true
    writable: false,//对象属性是否可修改,flase为不可修改，默认值为true
    value: 'xiaoxiao' //对象属性的默认值，默认值为undefined
});
```
也就是说，**全局作用域下var声明的变量是不可删除**的，来测试下：
```javascript
// 以下的验证都是使用chrome浏览器的默认js执行环境-非严格模式下的返回结果

delete aaa  // false
console.log(aaa)  // 1, 依然存在

delete bbb  // true
console.log(bbb) // VM805:1 Uncaught ReferenceError: bbb is not defined  报错，说明已经删除掉了

delete ccc // true
console.log(ccc) // 报错，说明可删除

delete ddd  // true
console.log(ddd) // 报错，说明可删除
```

2. 函数作用域内声明变量有var和没var的区别

看一个非常简单的梨子：
```javascript
var x = 8
function fn() {
    var a = 1
    b = 2  // 隐式全局变量
    return a + b + x
}
fn()  // 3

console.log(a)  // Uncaught ReferenceError: a is not defined
console.log(b)  // 2
```
分析一下上面的代码：
- 在全局作用域下声明了一个变量x并且赋值为8，声明了一个函数fn，然后调用这个函数
- 在全局环境中访问函数作用域下var声明的变量a时会报错，因为在函数作用域下，var声明之后会被变量提升到当前作用域下的顶部，也就是说这个变量是函数作用域下的，在全局作用域中是无法访问的，报错信息的`ReferenceError: a is not defined`，全局作用域下是没有这个变量的。
- 函数fn中还有一个变量b，没有使用var声明，而是直接赋值，这时我们在全局作用域下访问b的时候是能够访问到的：`window.b => 2`，也就是说b变成了全局对象window的一个属性。能不能删除呢？`delete b => true`，再次访问就会报错了，所以这种方式的变量是可以删除的。
- 还有一点会发现，在函数内部是可以调用全局下的变量x的，这就涉及到作用域与作用域链的概念，简单说就是在函数作用域下没有找到这个变量就会沿着作用域链往上查找，直到查找到全局作用域。所以，**在函数内部可以沿着作用域链访问定义在函数外部的变量**。
- 注意：在ES5的严格模式下，如果变量声明没有var，去delete时就会报` SyntaxError`。

关于隐式全局变量变量有几点需要注意：

```javascript
function  fn() {
   var  a  =  b  =  c  =  1;   // b和c是隐式全局变量（等号）
   var  a = 1;  b = 2;  c = 3;     // b和c是隐式全局变量（分号）

   var  a = 1 ,  b = 2 ,  c = 3;    // b和c不是隐式全局变量（逗号）
}
```

> 关于JS的执行机制，什么是变量提升，为什么要变量提升，作用域以及作用域链是什么，执行环境是什么这几个问题是我们深入理解JS的基础，都是很重要的内容，将会使用单独的章节进行详细分析。

## 说一下JS中的delete

> 看到很多博文上建议说delete少用，使用了delete并不是真正的删除，delete的那个变量还是存储在内存中的，这里确实有点蒙圈，有人面试遇到过，整理下

1. delete的作用：删除对象的某个属性
2. 语法：`delete object.property`或者`delete object['property']`
   ```javascript
   var doggy = {
      name: 'Bob',
      age: 3
   }

   delete doggy.name
   console.log(doggy)  // {age: 3}
   ```
3. 返回值：delete操作符的返回值是布尔值，如果是可删除的内容，执行delete操作，删除成功返回值为true，如果是不可删除的内容，执行delete操作，删除成功，返回值为false。
   
   比如，就像上面提到的`Object.getOwnPropertyDescriptor(window, 'aaa')
 => {value: 1, writable: true, enumerable: true, configurable: false}`，`configurable`的值为false，就表示是不可删除的属性，执行`delete aaa`得到的返回值就是false。

4. 实践应用：
   1. 删除一个对象中不存在的属性
   使用delete删除一个不存在的属性，delete操作无效，但是返回值仍然是true。
   ```javascript
   var doggy = {
      name: 'Bob',
      age: 3
   }
   delete doggy.sister  // true
   ```
   2. 能否删除原型链上的同名属性
   ```javascript
   // 构造函数
   function Person() {
      this.name = '李易峰',
      this.job = '明星演员'
   }

   Person.prototype.name = '李贺'  // 原型上有一个同名属性

   // 创建实例对象
   var p = new Person()
   // 删除p的name属性
   delete p.name
   console.log(p)  // Person {job: "明星演员"} , 对象中name这个属性已经被删除掉了
   console.log(p.name)  // '李贺'
   ```
   也就是说，使用delete删除成功之后的属性是不存在了，但是如果它的原型链上还存在一个同名属性的话是没有办法通过delete删除的，再次访问对象p的name属性时，访问的是从原型上继承过来的属性。
   
   需要注意的是，delete操作与内存管理没有关系，也就是有博客中所指出的**delete并不能将一个属性从内存中删除掉**观点，但是删除之后到底是什么，在内存里面是什么样子的还需要进一步探究！！！
   
   关于内存管理的内容可以参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)。垃圾回收机制会有专门的章节介绍。

   3. 删除var声明的变量与函数
   在`使用var声明变量与不使用var变量直接赋值的区别`中已经详细给出了几个简单的梨子已经相关验证，除此之外，这里来看下函数声明与函数表达式使用delete会怎么样呢？

   ```javascript
   var f1 = function () {
      console.log(1)
   }

   delete f1  // 严格模式下，会报错
   f1()  // 非严格模式下，控制台会输出1
   ```
   也就是说delete一个通过函数表达式定义的函数得到的结果与删除var声明的变量是一样的。
   
   另外，如果一个函数是一个对象的方法，是可以delete的。看下面：
   ```javascript
   var person = {
      name: '李易峰',
      show: function () {
         console.log('给大家表演个节目叭！')
      }
   }
   delete person.show  // true 表示删除成功
   console.log(person)  // {name: "李易峰"}
   ```

   4. 能否删除let和const声明的变量
   答案是不能删除。删除let和const声明的变量与删除var声明的变量得到的效果是一样的。
   5. 不可设置的属性不可删除
   - Math、Array、Object等内置对象的属性不可删除、方法可删除
   
      以Math为例，先来看下都有什么属性和方法：
      ![](../../images/Network/Math.png)

      ```javascript
      // 属性
      console.log(Math.E)  // 2.718281828459045
      delete Math.E   // false
      console.log(Math.E)  // 2.718281828459045

      // 方法
      console.log(Math.abs)  // ƒ abs() { [native code] }
      delete Math.abs  //  true
      console.log(Math.abs) // undefined
      ```
   - `Object.defineProperty()`设置为不可设置的属性不可删除
      ```javascript
      var person = {}
      Object.defineProperty(person, 'name', {
         value: '李易峰',
         configurable: false
      })

      delete person.name  // 非严格模式下，false， 严格模式下报语法错误
      console.log(person)  // {name: "李易峰"}
      ```
   6. 数组的删除
   删除数组中的某个元素：
   ```javascript
   var arr = ['李易峰','顾耀东','陈深','百里屠苏']
   console.log(arr.length)  // 4

   delete arr[0]  // true
   console.log(arr) // [empty, "顾耀东", "陈深", "百里屠苏"]
   console.log(arr.length)  // 4
   console.log(arr[0])  // undefined
   console.log(0 in arr)  // 0 in arr中0表示数组属性或索引，返回结果为false
   ```
   也就是说，
   - delete可以删除数组中的一个元素
   - 使用delete删除数组中元素以后，这个数组的长度是不会发生变化的
   - 删除之后数组中当前位置为empty，并且`console.log(0 in arr)`返回结果为false，表示0这个索引在数组中不存在了，现在数组中的索引是从1开始的。

   ```javascript
   var arr = ['李易峰','顾耀东','陈深','百里屠苏']
   arr[1] = undefined
   console.log(arr)  // ["李易峰", undefined, "陈深", "百里屠苏"]
   console.log(1 in arr)  // true, 表示1这个索引还是存在的
   ```  
   参考链接：[Javascript中的delete操作符](https://segmentfault.com/a/1190000010574280)







