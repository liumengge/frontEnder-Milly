## 前端跨域通信的方式

### JSONP

- JSONP: JSON with Padding， 填充JSON
- 案例引入：
  - 服务端存储天气数据："南京 晴 18~25"
  - 客户端：ajax调用服务端的天气数据，成功拿到数据后以弹窗的形式显示出来
  - 代码实现：
  - 服务端程序：
    ```javascript
    // 服务器程序：server.js
    const http = require('http')
    // 创建服务端程序实例
    http.createServer((req, res) => {
        // 每当有客户端发来请求时，自动调用一下回调函数
        var weather = "南京 晴 18~25"
        res.writeHead(200, {
            "Content-Type": "text/plain; charset=utf-8"
        })
        res.write(weather)
        res.end()
    }).listen(3000)

    // 在终端启动写好的服务器程序：node server.js 
    // 测试服务器是否正常
    // 浏览器地址栏输入http://localhost:3000
    ```
  - 客户端：
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>JSONP学习</title>
        <script src="./jquery.js"></script>
        <script>
            $(function(){
                $("#btn").click(function(){
                    $.ajax({
                        type:'get',
                        url:'http://localhost:3000',
                        success:function(data){
                            alert(data)
                        },
                        error:function(data){
                            console.dir(data);
                            console.log('error');
                        }
                    });
                });
            });
        </script>
    </head>
    <body>
        <input type="button" value="点击" id="btn">
    </body>
    </html>
    ```
页面上点击按钮时就会向我们写好的服务器程序发起请求，我们知道ajax是不支持跨域请求的，得到的结果是：
![](../../images/JS/ajax跨域-1.png)

- 如何解决ajax跨域问题？
  - 可以实现跨域请求的标签有哪些？
    - `<img src="其它网站的图片">`：可以成功显示请求的图片，说明不受同源策略的限制
    - `<link href="theme.css">`：可成功请求其它网站的css资源，不受同源策略的限制
    - `<script src="http://localhost:3000"></script>`: 测试发现，同样是向我们刚才写好的服务器程序请求数据，能够请求成功，说明script标签本身不受同源策略的限制,但是需要注意的是，服务端返回的应该是js语句，如果还是以之前字符串的形式返回会报语法错误。原因是，从服务端请求到的内容会被js引擎当作js语句执行，js引擎不能直接解析字符串。

- 原理：script标签的src属性不受同源策略的限制，可以跨域访问js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码。具体来说就是客户端利用script标签可以跨域请求资源的性质，向网页中动态插入script标签，来向服务端请求数据；服务端会解析请求的url，至少从请求参数中拿到一个回调函数(cb=myCallback)参数，将数据当作函数参数放入其中，返回给客户端；jsonp仅支持get类型的方式。

接下来，慢慢解释下为什么叫JSONP？回调函数的函数名如何在客户端与服务端保持一致？为什么需要动态插入script标签？等等一系列对于看到上述原理产生的疑问。

首先，上面提到，如何服务端直接返回给客户端一个字符串会报语法错误，也就是说script发起请求之后客户端想要的一段可执行的js代码，而不是字符串, 所以可以将想在客户端执行的代码在服务端拼接好之后再返回回来就可以执行了。


修改下客户端请求数据的方式：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSONP学习</title>
    <script src="./jquery.js"></script>
    <script src="http://localhost:3000"></script>
</head>
<body>
    
</body>
</html>
```

修改下服务端的返回：
```javascript

const http = require('http')
http.createServer((req, res) => {
    var weather = "南京 晴 18~25"
    res.writeHead(200, {
        "Content-Type": "text/plain; charset=utf-8"
    })
    // 想在客户端执行：document.write("天气")
    res.write(`document.write("${weather}")`)   // 修改
    res.end()
}).listen(3000)
```

上述代码可以看到，将原来的直接将weather字符串变量传给客户端变成了这样的一个模板字符串的形式，weather字符串变量放在了`${}`中，实际上,传给客户端的就是`document.write("南京 晴 18~25")`。注意，修改服务器程序之后记得重启一下。现在来测试一下服务器，会发现拿到的就是`document.write("南京 晴 18~25")`这条js语句，这条语句放在控制台里面是可以执行的，客户端的script拿到之后也能执行。

现在重新刷新页面,`南京 晴 18~25`就会显示在页面上了，客户端拿到的是`document.write("南京 晴 18~25")`代码，script一执行就会显示在页面上了。

使用script将最简单的跨域请求实现了，那为什么叫JSONP呢？应该能感知到了，JSON填充，就是发生在服务端返回给客户端内容的时候，将客户端请求的天气数据weather填充到一条合法的js语句中进而返回一条js语句到客户端被script自动执行，就是通过这种方式实现跨域请求的。

但是，会发现，现在的这种实现方案是把代码直接在服务端写死了，有的需要在客户端直接显示在页面上，有的想要弹窗的形式显示出来，显然不够灵活。

_**改进1:**_ 在客户端定义一个函数，利用这个函数来指定拿到数据后的操作，比如显示在页面上或者做其它的事情都可以在这个函数中自己定义。

一般我们调用一个函数是这样子做的：
```javascript
function show(weather) {
    document.write(weather)
    // alert(weather)
    // console.log(weather)
}
show("来自我自己的天气预报数据")
```
直接调用执行，肯定没问题。所以现在就明确了，我想要从服务端请求的数据是weather，拿到数据之后想要通过show函数来控制这个数据的操作，在服务端把数据weather填充到`show()`函数当中返回给客户端这样一条函数调用的js语句就可以了。

修改一下服务器返回：
```javascript
res.write(`show("${weather}")`)
```
重启测试，没有问题，依然能够请求成功，随意修改show函数里面的代码都可以完成相应的操作。需要注意的是：客户端与服务端的函数名要保持一致，返回到客户端才能正常执行。

上述方案也存在问题：服务端返回的调用函数名还是写死的，不够灵活。

_**改进2：**_通过请求参数传递给服务端调用函数名，这样就可以由客户端来决定调用函数名称了。

客户端：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSONP学习</title>
    <script src="./jquery.js"></script>
    <script>
        function show(weather) {
            document.write(weather)
        }
    </script>
    <script src="http://localhost:3000?callback=show"></script>
</head>
<body>
</body>
</html>
```

服务端：
```javascript
const http = require('http')
const url = require('url')

http.createServer((req, res) => {
    var Url = url.parse(req.url, true)
    var callback = Url.query.callback  // 从请求参数中获取callback参数
    var weather = "南京 晴 18~25"
    res.writeHead(200, {
        "Content-Type": "text/plain; charset=utf-8"
    })
    res.write(`${callback}("${weather}")`)  // 将函数名变量拼接后返回给客户端
    res.end()
}).listen(3000)
```

上述改进方案还有一个缺点在于，script标签本身是写死的，页面加载时只能执行一次，如果有需要反复请求的场景就不能完成了。

_**改进3：**_动态生成script标签，按需发起请求

客户端：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSONP学习</title>
    <script src="./jquery.js"></script>
    <script>
        function show(weather) {
            alert(weather)
        }
    </script>
    
</head>
<body>
    <button>天气预报</button>
    <script>
        $("button").click(function () {  
            // 点击按钮发送请求，显示天气
            var script = document.createElement('script')
            var url = "http://localhost:3000?callback=show"
            script.setAttribute('src', url)
            document.getElementsByTagName('head')[0].appendChild(script)
        })
    </script>
</body>
</html>
```
服务端：不需要修改

经过上述修改，每次点击页面上的按钮时都会向服务端发起一个数据请求，查看一下页面元素就是这样的：

![](../../images/JS/script请求.png)

实际上，这样的script作用就是向服务端请求数据的，发完这次数据请求之后就没有什么作用了，所以就可以考虑在调用完回调函数之后直接清楚，以保持页面整洁：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSONP学习</title>
    <script src="./jquery.js"></script>
    <script>
        function show(weather) {
            alert(weather)
            // 调用函数结尾：删除用过的script元素
            $("head>script:last").remove()
        }
    </script>
    
</head>
<body>
    <button>天气预报</button>
    <script>
        $("button").click(function () {  
            // 点击按钮发送请求，显示天气
            var script = document.createElement('script')
            var url = "http://localhost:3000?callback=show"
            script.setAttribute('src', url)
            document.getElementsByTagName('head')[0].appendChild(script)
        })
    </script>
</body>
</html>
```


-总结：
  - 方案一：用`<script src="服务端接口地址"></script>`代替$.ajax发送请求。
    - 服务端：将要发送的数据填充到一条js语句中返回给客户端
    - 客户端：`<script src="服务端接口地址"></script>`,script发送请求到服务端并能够收到服务端返回的js语句，script只要收到js语句就会立刻自动执行
    - 存在问题：要在客户端执行的js语句，在服务端写死了，不灵活，众口难调
  - 方案二：提前在客户端定义一个函数，用于处理服务端返回的请求，服务端仅仅使用函数名拼接一条函数调用的js语句。
    - 客户端：`function show(data) { 任意js语句 }`
    - 服务端：`res.write(`show("${weather}")`)`, 函数名要保持一致
    - 存在问题：各个不同的客户端，函数名是根据自己的需要定义的，方案二中服务端返回的调用函数名还是写死的，不灵活
  - 方案三：用请求参数将函数名传递给服务器
    - 客户端：`<script src="http://localhost:3000?callback=show"></script>`
    - 服务端：接收客户端传来的名为callback的参数中保存的函数名，将callback函数名动态拼接到要返回的函数调用语句中
    - 存在问题：这种方案已经是比较灵活了，但是script在页面中是写死的，在页面加载中这个script只能执行一次，无法按需反复执行，比如每次点击按钮时，随时发送请求。
  - 方案四：每次点击按钮时动态创建script元素
    - 客户端：动态创建script元素追加在head尾部，回调函数调用完成之后删除，这样不会造成script元素的堆积
    - 服务端：不需要修改
    - 注意：请求参数callback是要提前商定好的，因为客户端要使用这个参数名将回调函数传递给服务端，服务端需要从url中使用这个请求参数名获取到回调函数名后拼接返回给客户端。
