## HTT网络层的前端性能优化
- HTTP网络层优化
- 代码编译层优化 webpack
- 代码运行层优化 html/css+js+vue+react
- 安全优化 xss+csrf
- 

CRP：关键渲染路径

经典面试“从输入URL地址到看到页面，中间经历了什么


url解析：
    - 组成
    - url编码：防止中文乱码，查询参数部分进行编码
    - encodeRUI，整个url编码， decodeURI解码，主要处理空格，中文...，
    - 如果一个url的查询字符串中有一个url可能会被解析识别成两个地址
    - 主要对传递的参数编码，encodeURIComponent，对处理冒号双斜杠处理等

escape编码，后端有可能没有解码方法，就不能用了

- URI URL URN 区别


- 缓存检查 --- 产品性能优化的重点 --- 强缓存与协商缓存，先检查强缓存，有且为失效，走强缓存，如果没有或者失效，检测是否有协商缓存，有的话就走协商缓存，没有的话就获取最新数据

  - 缓存位置：
    - 内存缓存，可能浏览器一关闭可能就没有了
    - 硬盘缓存
  
  打开网页：查找disk cache里面是不是有匹配内容，有就使用，没有就发送网络请求
  普通刷新（F5）页面没关闭，因此内存可用，会被优先使用，其次时硬盘
  强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头都带cache-control:no-cache, 200, 最新内容

强缓存
- Expires
- cache-control
- 两者都有，cache-control优先级高
- 特点：资源缓存在本地，本地有，没过期
- html页面一般不做强缓存，对于不经常更新的文件可以做强缓存，每一次html的请求都是走正常的http请求
- 强缓存有问题，服务器内容更新，本地还是有缓存的，这样就拿不到最新信息了
  - 1. 服务器更新资源后，让资源名称和之前不一样，这样页面导入的是新的资源：index.12323.js -> index.34234.js  webpack hash name 
  - 2. 当文件更新后，在html导入时，设置一个时间戳后缀 `<script src='index.js?2343242342'></script>`
  - 3. 不用强缓存 --- 协商缓存
    - 强缓存失效后，浏览器携带缓存表示向服务器发出请求
    - 区别：协商缓存，总会和服务器协商，所以一定会发http请求，哪怕本地有缓存也会发出http请求
    - http1.0 last-modified， http1.1 
    - 第一次向服务器发送请求，这时协商缓存没有，没有传任何标识，服务器收到请求之后准备内容，last-modified记录当前资源文件最后更新的时间，Etag记录的是一个标识，也是根据文件更新生成的，每一次资源更新都会重新生成一个Etag，客户端拿到信息后渲染，把信息和标识缓存在本地，
    - 第二次发请求，if-Modified-Since = last-modified值， if-none-match=etag值，给服务器，服务器根据标识判断文件是否更新
    - 先走强缓存再走协商缓存如何理解？
- 数据缓存
  - ajax fetch 发送请求
  - 检测本地缓存的数据信息，有，且未过期，直接根据本地的数据进行渲染，没有或者过期，基于ajax从服务器获取最新的数据信息，把数据
- DNS解析
  - 递归查询
  - 迭代查询
- DNS也是可能有缓存的
- 每一次DNS解析时间预计再20-120毫秒
  - 减少DN请求次数
  - DNS
  - 项目中旺旺会把不同的资源放在不同的服务器上
- 第四步：TCP三次握手
  - 