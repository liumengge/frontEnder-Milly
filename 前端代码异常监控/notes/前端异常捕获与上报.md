> 尽管在code的时候很小心地避免出错，并且一个功能的正式上线大多会经历自测、联调、CR、QA测试一系列质量保障过程，但是还是会出现意想不到的异常报错导致脚本停止运行。刚好近期也在做前端后台系统错误信息上报的任务，为了更好地避免前端错误以及主动发现错误，我觉得有必要详细认识一下前端异常捕获与上报。本文是一篇学习记录，梳理了前端异常类型、处理方式、错误信息上报相关内容，如有理解有误的地方，希望各位大佬不吝赐教~

程序错误，来自wiki的定义：Bug，程序设计的术语，指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象。有些bug会造成计算机安全隐患，此时叫漏洞。不想变成一个bug写手，最好是知道bug产生的原因，能不能有办法处理异常以不影响程序运行，就算是不幸吃了一个bug，能不能快速定位，敏捷修复？嗯，会的，一定会写出优美健壮的代码！

## 前端异常

> JS代码的执行有两个阶段：预编译+代码执行，这两个阶段都有可能出现异常。可参考之前整理过的[JS引擎执行机制](https://github.com/liumengge/frontEnder-Milly/tree/master/00.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90)。

### 编译时异常 与 运行时异常

1. 定义：
  - 编译时异常：是在JS预编译阶段出现的异常
  - 运行时异常：是JS代码运行时出现的异常。很显然，预编辑阶段通过了，JS代码在真正运行时出现了异常
2. 编译时异常很容易发现，因为在代码预编译阶段若存在异常就直接输出在浏览器控制台了，比较难搞的是运行时异常。
3. 举个例子：

eg.1:
```javascript
function test_1() {
  console.log('start')
  await test_A()
  console.log('end')
}
test_1()
```

在浏览器控制台执行就会看到报错信息:

![](image/parse-err1.jpg)

test_1函数在预编译阶段就出现了语法错误，还没有真正执行，所以并不会打印start。

eg.2:
```javascript
const user = {
  name: 'Milly'
}
const isAl = true
function test_2() {
  console.log('start')
  if (isAl) {
    alert(`Hi, I'm ${ user.name }. I am a ${ user.job } working in ${ user.job.addr }`)
  } else {
    console.log('Milly')
  }
  console.log('end')
}
test_2()
```
控制台输出：

![](image/run-err2.jpg)

控制台打印出了start，但是执行到user.job.addr时，由于user中job字段为undefined所以抛出了如图所示的异常。此外，end字段并没有被打印出来，也就是说执行到这里抛出异常，JS代码也就不会继续往下执行了。

在日常业务开发中，类似这样的错误很容易像eg.2一样被隐藏在流程控制语句中，尤其是开发自测的需求，很难覆盖所有的case，极有可能因为接口数据不规范等原因出现这样的异常。

### 语法错误 与 逻辑错误

1. 定义：
   - 语法错误：代码中存在拼写错误，将导致程序完全或部分不能运行，这类错误根据错误提示信息基本可修复
   - 逻辑错误：语法正确但执行结果和预期相悖。程序虽能运行但会给出错误的结果，一般不会收到来自这些错误的提示，所以逻辑错误通常比语法错误难修复。
2. 简单例子：
  
    eg.3
    ```html
    <style>
      .app {
        width: 100px;
        height: 100px;
        border: 1px solid red;
      }
    </style>

    <body>
    <div class="app"></div>
      <script>
        const app = document.querySelector('app')
        app.textContent = 'This is ...'
      </script>
    </body>
    ```
    控制台拿到的结果：
    ![](image/type-err1.jpg)
  - Uncaught标识标识是未被捕获的异常
  - 提示错误为TypeError
  - 冒号后面给出错误描述信息
  - 最右端有错误在文件中的行号
  - 错误类型以及错误描述信息下方是错误的堆栈信息，可以根据该信息快速定位
  
    可以看到，控制台给出的语法错误信息很详细，根据错误相关信息即可快速定位及修复

3. [查找并解决JS代码的错误](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_went_wrong)

### 同步异常 与 异步异常

1. 定义：
   - 同步异常：在主线程上排队执行的任务时出现的异常，JS代码由上到下依次执行过程中出现的异常
   - 异步异常：执行异步任务时出现的异常，比如在文件读取、ajax数据请求过程中出现的异常等
2. 举个例子：

    eg.4: NodeJS同步读取文件内容
    ```javascript
    const fs = require('fs')

    fs.readFileSync('readme.milly')
    console.log('Milly')
    ```

    ![](image/readFileSync-err3.jpg)

    eg.5: NodeJS异步读取文件内容
    ```javascript
    const fs = require('fs')

    fs.readFile('readme.milly', (err, data) => {
      if(err) {
        throw err
      }
    })
    console.log('Milly')
    ```
    ![](image/readFile-err5.jpg)

## 异常处理

### 异常如何呈现在控制台上的

JS异常被抛出后就会沿着函数调用栈逐层传递出来，如果异常在逐层传递的过程中没有被捕获，就会像eg.1中一样展示在控制台上，而且会有一个Uncaught标识；如果异常在传递过程中遇到catch就会被捕获而不会有Uncaught标识。

### 异常捕获与处理

1. try-catch只能捕获当前调用栈的错误

首先，明确try-catch-finally的执行逻辑：
![](image/try-catch.png)

所以，通过使用try-catch就可以在catch分支捕获到在try块中抛出的异常而不会导致脚本终止执行。但在使用try-catch时有几点需要注意：

- try-catch只能捕获运行时异常，对于编译时异常是无法捕获的，比如：
  eg.6:
  ```javascript
  try {
    console.log('start')
    test_3()
    console.log('end')
  } catch (error) {
    console.log('捕获到的错误信息', error)
  }
  ```
  ![](image/try-err1.jpg)

  eg.7:
  ```javascript
  try {
    console.log('start')
    test_3（）
    console.log('end')
  } catch(error) {
    console.log('捕获到的错误信息', error)
  }
  ```
  ![](image/try-err2.jpg)
  eg.6中，test_3函数没有定义，属于运行时错误，可以被catch到，而eg.7中在调用函数test_3的地方不小心把后面的括号写成了中文的，这个时候的语法错误在预编译阶段就会被抛出，不会被catch到。从这两个小例子中也能看出来，未被捕获到的异常，最终会输出在控制台上并标有Uncaught字样，而被catch到的异常打印在控制台上时是没有Uncaught标识的。
- try-catch无法catch到异步异常，因为try-catch只能捕获当前调用栈中的错误。通过例子来看会比较清晰，还是以同步、异步文件读取为例：  
  eg.8:
  ```javascript
  try {
    fs.readFileSync('readme.milly')
    console.log('Milly')
  } catch (error) {
    console.log('catch', error)
  }
  ```
  ![](image/try-err3.jpg)
  eg.8是在eg.4的基础上添加了try-catch进行异常捕获，从上图结果中可以看出，在读取一个不存在的文件时出现异常并被catch到了。

  eg.9:
  ```javascript
  const fs = require('fs')

  try {
    fs.readFile('readme.milly', (err, data) => {
      if(err) {
        throw err
      }
    })
    console.log('Milly')
  } catch (error) {
    console.log('catch', error)
  }
  ```
  ![](image/try-err5.jpg)
  eg.9是在eg.5的基础上添加了try-catch来捕获异常，从上图结果中可以看到在异步文件读取的回调函数中抛出了一个错误，但是并没有被catch到。那回调函数中的异常要怎么处理呢？调整下吧，在回调函数中处理：

  eg.10:
  ```javascript
  const fs = require('fs')

  fs.readFile('readme.milly', (err, data) => {
    try {
      if (err) {
        throw err
      }
    } catch (error) {
      console.log('catch', error)
    }
  })
  ```
  ![](image/try-err6.jpg)
  像这样调整下捕获位置，就可以捕获到异步回调中出现的错误了。
  
  但是为什么呢？为什么try-catch无法直接捕获异步异常？原因是，它只能捕获当前函数调用栈中抛出的异常，这里可以来看下调用栈：
  
  eg.11:
  ![](image/1640103398835.jpg)
  上图中try-catch只能捕获所在调用栈中抛出的异常，也就是红色框所在的匿名函数调用栈中，但是真正的异常是在定时器的回调函数中抛出的(蓝色箭头指的函数调用栈), Error不会被捕获。这样分析来看，将try-catch放在抛出异常所在的回调函数内就可以了，试下：
  ![](image/try-err8.jpg)
  确实，若想捕获异步异常，就需要将try-catch写入回调函数中，始终将try-catch放在可能会抛出异常的当前函数作用域就可以捕获到异常了。

- try-catch捕获promise的reject异常
  
  在Promise的executor和handler中存在隐式的`try-catch`，若抛出异常，该异常就会被catch到，此时为rejection。

  eg.12:
  ```javascript
  new Promise((resolve, reject) => {
    // reject('This is an error in executor')       1
    // throw new Error('This is an error in executor')    2
    resolve('test')
  }).then((res) => {
    throw new Error('This is an error in handler')     //  3
  }).catch((err) => {
    console.log('catch error', err)
  })
  ```
  上述例子中，在1、2、3处抛出的异常在catch中均能被捕获到。

- try-catch捕获async/await异常

  eg.13:
  ```javascript
  async function test() {
    try {
      let response = await fetch('/no-user-here')
      let user = await response.json()
    } catch(err) {
      // 捕获到 fetch 和 response.json 中的错误
      alert(err)
    }
  }
  test()
  ```

  ```javascript
  async function f() {
    let response = await fetch('http://no-such-url')
  }

  // f() 变成了一个 rejected 的 promise
  f().catch(alert)  // TypeError: failed to fetch
  ```

1. window.onerror

2. window.unhandledrejection

3. app.config.errorHandler

### 异常上报

TraceKit - 跨浏览器堆栈跟踪日志标准


## 参考

- [Error-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)
- [你不知道的前端异常处理](https://segmentfault.com/a/1190000022977773)
- [函数式编程](https://github.com/azl397985856/functional-programming)
- [自定义Error](https://zh.javascript.info/custom-errors#kuo-zhan-error)