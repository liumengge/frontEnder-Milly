> 尽管在code的时候很小心地避免出错，并且一个功能的正式上线大多会经历自测、联调、CR、QA测试一系列质量保障过程，但是还是会出现意想不到的异常报错导致脚本停止运行。刚好近期也在做前端后台系统错误信息上报的任务，为了更好地避免前端错误以及主动发现错误，我觉得有必要详细认识一下前端异常捕获与上报。本文是一篇学习记录，梳理了前端异常类型、处理方式、错误信息上报相关内容，如有理解有误的地方，希望各位大佬不吝赐教~

程序错误，来自wiki的定义：Bug，程序设计的术语，指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象。有些bug会造成计算机安全隐患，此时叫漏洞。不想变成一个bug写手，最好是知道bug产生的原因，能不能有办法处理异常以不影响程序运行，就算是不幸吃了一个bug，能不能快速定位，敏捷修复？嗯，会的，一定会写出优美健壮的代码！

## 前端异常

> JS代码的执行有两个阶段：预编译+代码执行，这两个阶段都有可能出现异常。可参考之前整理过的[JS引擎执行机制](https://github.com/liumengge/frontEnder-Milly/tree/master/00.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90)。

### 编译时异常 与 运行时异常

1. 定义：
  - 编译时异常：是在JS预编译阶段出现的异常
  - 运行时异常：是JS代码运行时出现的异常。很显然，预编辑阶段通过了，JS代码在真正运行时出现了异常
2. 编译时异常很容易发现，因为在代码预编译阶段若存在异常就直接输出在浏览器控制台了，比较难搞的是运行时异常。
3. 举个例子：

eg.1:
```javascript
function test_1() {
  console.log('start')
  await test_A()
  console.log('end')
}
test_1()
```

在浏览器控制台执行就会看到报错信息:

![](image/parse-err1.jpg)

test_1函数在预编译阶段就出现了语法错误，还没有真正执行，所以并不会打印start。

eg.2:
```javascript
const user = {
  name: 'Milly'
}
const isAl = true
function test_2() {
  console.log('start')
  if (isAl) {
    alert(`Hi, I'm ${ user.name }. I am a ${ user.job } working in ${ user.job.addr }`)
  } else {
    console.log('Milly')
  }
  console.log('end')
}
test_2()
```
控制台输出：

![](image/run-err2.jpg)

控制台打印出了start，但是执行到user.job.addr时，由于user中job字段为undefined所以抛出了如图所示的异常。此外，end字段并没有被打印出来，也就是说执行到这里抛出异常，JS代码也就不会继续往下执行了。

在日常业务开发中，类似这样的错误很容易像eg.2一样被隐藏在流程控制语句中，尤其是开发自测的需求，很难覆盖所有的case，极有可能因为接口数据不规范等原因出现这样的异常。

### 语法错误 与 逻辑错误

1. 定义：
   - 语法错误：代码中存在拼写错误，将导致程序完全或部分不能运行，这类错误根据错误提示信息基本可修复
   - 逻辑错误：语法正确但执行结果和预期相悖。程序虽能运行但会给出错误的结果，一般不会收到来自这些错误的提示，所以逻辑错误通常比语法错误难修复。
2. 简单例子：
  
    eg.3
    ```html
    <style>
      .app {
        width: 100px;
        height: 100px;
        border: 1px solid red;
      }
    </style>

    <body>
    <div class="app"></div>
      <script>
        const app = document.querySelector('app')
        app.textContent = 'This is ...'
      </script>
    </body>
    ```
    控制台拿到的结果：
    ![](image/type-err1.jpg)
  - Uncaught标识标识是未被捕获的异常
  - 提示错误为TypeError
  - 冒号后面给出错误描述信息
  - 最右端有错误在文件中的行号
  - 错误类型以及错误描述信息下方是错误的堆栈信息，可以根据该信息快速定位
  
    可以看到，控制台给出的语法错误信息很详细，根据错误相关信息即可快速定位及修复

3. [查找并解决JS代码的错误](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_went_wrong)

### 同步异常 与 异步异常

1. 定义：
   - 同步异常：在主线程上排队执行的任务时出现的异常，JS代码由上到下依次执行过程中出现的异常
   - 异步异常：执行异步任务时出现的异常，比如在文件读取、ajax数据请求过程中出现的异常等
2. 举个例子：

    eg.4: NodeJS同步读取文件内容
    ```javascript
    const fs = require('fs')

    fs.readFileSync('readme.milly')
    console.log('Milly')
    ```

    ![](image/readFileSync-err3.jpg)

    eg.5: NodeJS异步读取文件内容
    ```javascript
    const fs = require('fs')

    fs.readFile('readme.milly', (err, data) => {
      if(err) {
        throw err
      }
    })
    console.log('Milly')
    ```
    ![](image/readFile-err5.jpg)

## 异常处理

### 异常是如何呈现在控制台上的？

JS异常被抛出后就会沿着函数调用栈逐层传递出来，如果异常在传递的过程中没有被捕获，就会像eg.1中一样展示在控制台上，而且会有一个Uncaught标识；如果异常在传递过程中遇到catch就会被捕获而不会有Uncaught标识。

### 异常捕获与处理

1. try-catch
  - try-catch只能捕获当前调用栈的错误

  首先，明确try-catch-finally的执行逻辑：
  ![](image/try-catch.png)

  所以，通过使用try-catch就可以在catch分支捕获到在try块中抛出的异常而不会导致脚本终止执行。但在使用try-catch时有几点需要注意：

  - try-catch只能捕获运行时异常，对于编译时异常是无法捕获的，比如：
    eg.6:
    ```javascript
    try {
      console.log('start')
      test_3()
      console.log('end')
    } catch (error) {
      console.log('捕获到的错误信息', error)
    }
    ```
    ![](image/try-err1.jpg)

    eg.7:
    ```javascript
    try {
      console.log('start')
      test_3（）
      console.log('end')
    } catch(error) {
      console.log('捕获到的错误信息', error)
    }
    ```
    ![](image/try-err2.jpg)
    eg.6中，test_3函数没有定义，属于运行时错误，可以被catch到，而eg.7中在调用函数test_3的地方不小心把后面的括号写成了中文的，这个时候的语法错误在预编译阶段就会被抛出，不会被catch到。从这两个小例子中也能看出来，未被捕获到的异常，最终会输出在控制台上并标有Uncaught字样，而被catch到的异常打印在控制台上时是没有Uncaught标识的。
  - try-catch无法catch到异步异常，因为try-catch只能捕获当前调用栈中的错误。通过例子来看会比较清晰，还是以同步、异步文件读取为例：  
    eg.8:
    ```javascript
    try {
      fs.readFileSync('readme.milly')
      console.log('Milly')
    } catch (error) {
      console.log('catch', error)
    }
    ```
    ![](image/try-err3.jpg)
    eg.8是在eg.4的基础上添加了try-catch进行异常捕获，从上图结果中可以看出，在读取一个不存在的文件时出现异常并被catch到了。

    eg.9:
    ```javascript
    const fs = require('fs')

    try {
      fs.readFile('readme.milly', (err, data) => {
        if(err) {
          throw err
        }
      })
      console.log('Milly')
    } catch (error) {
      console.log('catch', error)
    }
    ```
    ![](image/try-err5.jpg)
    eg.9是在eg.5的基础上添加了try-catch来捕获异常，从上图结果中可以看到在异步文件读取的回调函数中抛出了一个错误，但是并没有被catch到。那回调函数中的异常要怎么处理呢？调整下吧，在回调函数中处理：

    eg.10:
    ```javascript
    const fs = require('fs')

    fs.readFile('readme.milly', (err, data) => {
      try {
        if (err) {
          throw err
        }
      } catch (error) {
        console.log('catch', error)
      }
    })
    ```
    ![](image/try-err6.jpg)
    像这样调整下捕获位置，就可以捕获到异步回调中出现的错误了。
    
    但是为什么呢？为什么try-catch无法直接捕获异步异常？原因是，它只能捕获当前函数调用栈中抛出的异常，这里可以来看下调用栈：
    
    eg.11:
    ![](image/1640103398835.jpg)
    上图中try-catch只能捕获所在调用栈中抛出的异常，也就是红色框所在的匿名函数调用栈中，但是真正的异常是在定时器的回调函数中抛出的(蓝色箭头指的函数调用栈), Error不会被捕获。这样分析来看，将try-catch放在抛出异常所在的回调函数内就可以了，试下：
    ![](image/try-err8.jpg)
    确实，若想捕获异步异常，就需要将try-catch写入回调函数中，始终将try-catch放在可能会抛出异常的当前函数作用域就可以捕获到异常了。

  - try-catch捕获promise的reject异常
    
    在Promise的executor和handler中存在隐式的`try-catch`，若抛出异常，该异常就会被catch到，此时为rejection。

    eg.12:
    ```javascript
    new Promise((resolve, reject) => {
      // reject('This is an error in executor')       1
      // throw new Error('This is an error in executor')    2
      resolve('test')
    }).then((res) => {
      throw new Error('This is an error in handler')     //  3
    }).catch((err) => {
      console.log('catch error', err)
    })
    ```
    上述例子中，在1、2、3处抛出的异常在catch中均能被捕获到。

  - try-catch捕获async/await异常

    eg.13:
    ```javascript
    async function test_6() {
      try {
        let res = await fetch('http://test-url')
      } catch(error) {
        console.log(error)
      }
    }
    test_6()
    ```
    为什么try-catch可以直接捕获async/await的异常？

    async关键字表示该函数返回的是一个promise，如果return的不是一个显示的promise也会被包装成promise，如果一个promise正常resolve，await promise 返回的就是其结果，但是如果promise被reject，它将throw这个error，而await会让JS引擎等待直到promise完成(resolved或rejected)并返回结果。如果没有像eg.13一样使用`try-catch`捕获异常，也可以像下面例子中一样使用`.catch`来捕获。

    ```javascript
    async function test_6() {
      let res = await fetch('http://test-url')
    }

    // test_6() 变成了一个 rejected 的 promise
    test_6().catch((error) => {
      console.log(error)
    })
    ```
    实战项目中，通常async/await来处理promise而不是链式调用，配合`try-catch`捕获异常使得代码看起来更清晰明了。

2. window.onerror

`try-catch`可以实现局部异常捕获，如果是在try-catch外部出现的异常该如何捕获？使用`window.onerror`来实现全局异常捕获。

eg.14:
```javascript
window.onerror = function(message, source, line, col, error) {
  console.log('异常描述信息', message, source, line, col, error)
  console.log('发生错误的脚本文件', source)
  console.log('异常所在文件行列号', line, col)
  console.log('异常对象', error)
}

function test_7() {
  test_6()
}

test_7()
```

eg.14中在控制台打印出来的信息如下：
![](image/onerr-2.jpg)
控制台上console出来的信息好像没有什么用啊，而且出现了一个不知道是什么含义的`Script error.`，除此之外就没有其他有用信息了。。。

[![](image/onerr-3.jpg)](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror)

注意事项的意思就是说，这种获取不到具体错误信息的情况是跨域导致的，eg.14是直接在默认浏览器打开看到的结果，那换种方式-`Open with Live Server`，然后地址栏中输入`http://10.242.35.108:5502/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/demos/test2/`(端口号对应刚刚启动的server端口号，资源地址对应demo的index.html文件地址)：

![](image/onerr-4.jpg)

若在后续项目中遇到跨域导致无法捕获全局异常信息的情况可以参考[GlobalEventHandlers.onerror](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror)。

3. window.onunhandledrejection

如果在使用promise相关操作时如果忘记添加catch或者`async/await`没有`try-catch`异常捕获，就会有未被捕获的rejected异常被抛出，这时可以使用`window.onunhandledrejection`来全局捕获。

```javascript
window.onunhandledrejection = function(event) {
  console.log(event)
  console.log(event.promise)   // [object Promise] - 生成该全局 error 的 promise
  console.log(event.reason)
}

async function test_8() {
  let res = await test_9()
}
test_8()
```

同样的，`Open in Default Browser`不会触发onunhandledrejection，而`Open with Live Server`就可以拿到如下详细错误信息：

![](image/reject-err1.jpg)


4. app.config.errorHandler

> vue也提供了错误处理的配置属性`app.config.errorHandler`，vue2.x中使用`Vue.config.errorHandler`。

在vue3.x中，错误的捕获类型统一到了一个文件中，除了严重的任务直接报错阻碍应用运行，其他在各个生命周期以及各种钩子中的错误都能被errorHandler捕获到。如下图是[vue3.x源码中错误类型](https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/errorHandling.ts):

![](image/err-type.jpg)

至此，通过上述几种类型的demo已经明确如何捕获异常了，那捕获后的异常该如何处理呢？关于异常处理的一个原则就是：只处理能明确处理的异常，无法处理的异常再次手动抛出。在项目中，一种是捕获到异常给出适当的错误信息提示，进一步的，可以将捕获到的异常信息上报(Setnry)。

```javascript
window.onunhandledrejection = function(event) {
  console.log(event)
  console.log(event.promise)
  console.log(event.reason)
}

window.onerror = function(message, source, line, col, error) {
  console.log('异常描述信息', message)
  console.log('出现异常的脚本文件', source)
  console.log('异常所在文件行列号', line, col)
  console.log('异常对象', error)
}

;(async () => {
  try {
    // test_7()
    let res = await fetch('http://test-url')
  } catch (error) {
    if (error instanceof ReferenceError) {
      console.log('ReferenceError, do something here')
    } else {
      // 其他类型的错误不知道怎么处理，抛出
      throw new Error(`出现一个不知该如何处理的错误：${error}`)
    }
  }
})()
```

![](image/reject-err2.jpg)

小结：
- `try…catch`只能处理运行时错误
- `try…catch`捕获不到Promise中抛出的错误，以及异步的错误，需要将其调整到回调函数内执行异常捕获
- `try…catch`可以捕获 `async…await`中的异步错误
- `window.onerror`对于同域的js抛出的错误，error中包含了详情的错误信息，但对于跨域的js异常，只会在message中显示简单的 `Script error.`并且error为null
- `window.onerror`可以捕获到宏任务抛出的错误，微任务比如：Promise，和async函数抛出的错误捕获不到
- `window.onunhandledrejection`可以捕获Promise、async函数自动抛出或手动抛出的未被捕获的异常

### 异常上报

前端后台管理系统接入了哨兵，在捕获到异常后将错误对象上报，以及时发现问题、定位问题、解决问题。在将错误信息上报时引用了TraceKit这一跨浏览器堆栈跟踪日志标准化工具。为什么需要tracekit？因为并非所有浏览器都支持对错误对象的堆栈跟踪，不同的浏览器错误信息格式不一致。

这里使用的是`tracekit@0.4.6`，来看下是如何进行标准化的：

1. `TraceKit.report: Cross-browser processing of unhandled exceptions`
```javascript
/**
  * Syntax:
  * ```js
  *   TraceKit.report.subscribe(function(stackInfo) { ... })
  *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
  *   TraceKit.report(exception)
  *   try { ...code... } catch(ex) { TraceKit.report(ex); }
  * ```
  * Requires TraceKit.computeStackTrace.
  * /
```

2. `TraceKit.computeStackTrace: cross-browser stack traces in JavaScript`
```javascript
/**
 * Syntax:
 *   ```js
 *   s = TraceKit.computeStackTrace.ofCaller([depth])
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 *   ```
 */
```




## 参考

- [Error](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)
- [你不知道的前端异常处理](https://segmentfault.com/a/1190000022977773)
- [函数式编程](https://github.com/azl397985856/functional-programming)
- [自定义Error](https://zh.javascript.info/custom-errors#kuo-zhan-error)
- [GlobalEventHandlers.onerror](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror)
- vue应用配置
- [Read TraceKit](https://github.com/XXHolic/blog/issues/69#report)